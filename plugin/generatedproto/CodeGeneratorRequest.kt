// Code generated by Wire protocol buffer compiler, do not edit.
// Source: google.protobuf.compiler.CodeGeneratorRequest in plugin.proto
package com.google.protobuf.compiler

import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.ReverseProtoWriter
import com.squareup.wire.Syntax.PROTO_2
import com.squareup.wire.WireField
import com.squareup.wire.`internal`.immutableCopyOf
import com.squareup.wire.`internal`.redactElements
import com.squareup.wire.`internal`.sanitize
import kotlin.Any
import kotlin.AssertionError
import kotlin.Boolean
import kotlin.Deprecated
import kotlin.DeprecationLevel
import kotlin.Int
import kotlin.Long
import kotlin.Nothing
import kotlin.String
import kotlin.Unit
import kotlin.collections.List
import kotlin.jvm.JvmField
import okio.ByteString

/**
 *  An encoded CodeGeneratorRequest is written to the plugin's stdin.
 */
public class CodeGeneratorRequest(
  file_to_generate: List<String> = emptyList(),
  /**
   *  The generator parameter passed on the command-line.
   */
  @field:WireField(
    tag = 2,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
  )
  public val parameter: String? = null,
  proto_file: List<FileDescriptorProto> = emptyList(),
  /**
   *  The version number of protocol compiler.
   */
  @field:WireField(
    tag = 3,
    adapter = "com.google.protobuf.compiler.Version#ADAPTER",
    jsonName = "compilerVersion",
  )
  public val compiler_version: Version? = null,
  unknownFields: ByteString = ByteString.EMPTY,
) : Message<CodeGeneratorRequest, Nothing>(ADAPTER, unknownFields) {
  /**
   *  The .proto files that were explicitly listed on the command-line.  The
   *  code generator should generate code only for these files.  Each file's
   *  descriptor will be included in proto_file, below.
   */
  @field:WireField(
    tag = 1,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.REPEATED,
    jsonName = "fileToGenerate",
  )
  public val file_to_generate: List<String> = immutableCopyOf("file_to_generate", file_to_generate)

  /**
   *  FileDescriptorProtos for all files in files_to_generate and everything
   *  they import.  The files will appear in topological order, so each file
   *  appears before any file that imports it.
   *
   *  protoc guarantees that all proto_files will be written after
   *  the fields above, even though this is not technically guaranteed by the
   *  protobuf wire format.  This theoretically could allow a plugin to stream
   *  in the FileDescriptorProtos and handle them one by one rather than read
   *  the entire set into memory at once.  However, as of this writing, this
   *  is not similarly optimized on protoc's end -- it will store all fields in
   *  memory at once before sending them to the plugin.
   *
   *  Type names of fields and extensions in the FileDescriptorProto are always
   *  fully qualified.
   */
  @field:WireField(
    tag = 15,
    adapter = "com.google.protobuf.FileDescriptorProto#ADAPTER",
    label = WireField.Label.REPEATED,
    jsonName = "protoFile",
  )
  public val proto_file: List<FileDescriptorProto> = immutableCopyOf("proto_file", proto_file)

  @Deprecated(
    message = "Shouldn't be used in Kotlin",
    level = DeprecationLevel.HIDDEN,
  )
  public override fun newBuilder(): Nothing = throw
      AssertionError("Builders are deprecated and only available in a javaInterop build; see https://square.github.io/wire/wire_compiler/#kotlin")

  public override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is CodeGeneratorRequest) return false
    if (unknownFields != other.unknownFields) return false
    if (file_to_generate != other.file_to_generate) return false
    if (parameter != other.parameter) return false
    if (proto_file != other.proto_file) return false
    if (compiler_version != other.compiler_version) return false
    return true
  }

  public override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + file_to_generate.hashCode()
      result = result * 37 + (parameter?.hashCode() ?: 0)
      result = result * 37 + proto_file.hashCode()
      result = result * 37 + (compiler_version?.hashCode() ?: 0)
      super.hashCode = result
    }
    return result
  }

  public override fun toString(): String {
    val result = mutableListOf<String>()
    if (file_to_generate.isNotEmpty()) result +=
        """file_to_generate=${sanitize(file_to_generate)}"""
    if (parameter != null) result += """parameter=${sanitize(parameter)}"""
    if (proto_file.isNotEmpty()) result += """proto_file=$proto_file"""
    if (compiler_version != null) result += """compiler_version=$compiler_version"""
    return result.joinToString(prefix = "CodeGeneratorRequest{", separator = ", ", postfix = "}")
  }

  public fun copy(
    file_to_generate: List<String> = this.file_to_generate,
    parameter: String? = this.parameter,
    proto_file: List<FileDescriptorProto> = this.proto_file,
    compiler_version: Version? = this.compiler_version,
    unknownFields: ByteString = this.unknownFields,
  ): CodeGeneratorRequest = CodeGeneratorRequest(file_to_generate, parameter, proto_file,
      compiler_version, unknownFields)

  public companion object {
    @JvmField
    public val ADAPTER: ProtoAdapter<CodeGeneratorRequest> = object :
        ProtoAdapter<CodeGeneratorRequest>(
      FieldEncoding.LENGTH_DELIMITED, 
      CodeGeneratorRequest::class, 
      "type.googleapis.com/google.protobuf.compiler.CodeGeneratorRequest", 
      PROTO_2, 
      null, 
      "plugin.proto"
    ) {
      public override fun encodedSize(`value`: CodeGeneratorRequest): Int {
        var size = value.unknownFields.size
        size += ProtoAdapter.STRING.asRepeated().encodedSizeWithTag(1, value.file_to_generate)
        size += ProtoAdapter.STRING.encodedSizeWithTag(2, value.parameter)
        size += FileDescriptorProto.ADAPTER.asRepeated().encodedSizeWithTag(15, value.proto_file)
        size += Version.ADAPTER.encodedSizeWithTag(3, value.compiler_version)
        return size
      }

      public override fun encode(writer: ProtoWriter, `value`: CodeGeneratorRequest): Unit {
        ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 1, value.file_to_generate)
        ProtoAdapter.STRING.encodeWithTag(writer, 2, value.parameter)
        FileDescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 15, value.proto_file)
        Version.ADAPTER.encodeWithTag(writer, 3, value.compiler_version)
        writer.writeBytes(value.unknownFields)
      }

      public override fun encode(writer: ReverseProtoWriter, `value`: CodeGeneratorRequest): Unit {
        writer.writeBytes(value.unknownFields)
        Version.ADAPTER.encodeWithTag(writer, 3, value.compiler_version)
        FileDescriptorProto.ADAPTER.asRepeated().encodeWithTag(writer, 15, value.proto_file)
        ProtoAdapter.STRING.encodeWithTag(writer, 2, value.parameter)
        ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 1, value.file_to_generate)
      }

      public override fun decode(reader: ProtoReader): CodeGeneratorRequest {
        val file_to_generate = mutableListOf<String>()
        var parameter: String? = null
        val proto_file = mutableListOf<FileDescriptorProto>()
        var compiler_version: Version? = null
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> file_to_generate.add(ProtoAdapter.STRING.decode(reader))
            2 -> parameter = ProtoAdapter.STRING.decode(reader)
            15 -> proto_file.add(FileDescriptorProto.ADAPTER.decode(reader))
            3 -> compiler_version = Version.ADAPTER.decode(reader)
            else -> reader.readUnknownField(tag)
          }
        }
        return CodeGeneratorRequest(
          file_to_generate = file_to_generate,
          parameter = parameter,
          proto_file = proto_file,
          compiler_version = compiler_version,
          unknownFields = unknownFields
        )
      }

      public override fun redact(`value`: CodeGeneratorRequest): CodeGeneratorRequest = value.copy(
        proto_file = value.proto_file.redactElements(FileDescriptorProto.ADAPTER),
        compiler_version = value.compiler_version?.let(Version.ADAPTER::redact),
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L
  }
}
